package mongo

import (
    "os"
    "log"
    "time"
    "regexp"
    "errors"
  //env "github.com/kelseyhightower/envconfig"
    cnv "strconv"
    mgo "gopkg.in/mgo.v2"
    bson "gopkg.in/mgo.v2/bson"
)

var (
    masterSession session
    secs_per_doc = 60
    zero_host = "0000000000000000"
    Empty_Graph = make(map[string]Points)
)

type (
    session struct {
      dialInfo *mgo.DialInfo
      ms       *mgo.Session
    }

/*  mconf struct {
      Host   string
      Port   string
      User   string
      Pass   string
      AuthDB string
    }
*/
)

type XY []float32
type Points []XY

func Init(host, port, authdb, user, password string) error {

    if masterSession.ms != nil {
        return nil
    }

    mgo.SetDebug(true)

    var aLogger *log.Logger
    aLogger = log.New(os.Stderr, "", log.LstdFlags)
    mgo.SetLogger(aLogger)

    dialInfo := &mgo.DialInfo{
        Addrs: []string{host + ":" + port},
        Source: authdb,
        Username: user,
        Password: password,
    }



    ms, err := mgo.DialWithInfo(dialInfo)
    if err != nil {
        return err
    }
//    defer Client.Close()

    ms.SetMode(mgo.Monotonic, true)
    ms.EnsureSafe(&mgo.Safe{W:0, FSync:false})
    ms.SetBatch(200)
    ms.SetPrefetch(0.25)

    masterSession = session{dialInfo, ms}

    log.Println("Mongo client is initialized.")
    return nil
}


func GetGraphData(db, c, x, y string, from, to time.Time, labels []string) (error, map[string]Points) {
    //TODO validate input
    if len(db) == 0 || len(c) == 0 || len(x) == 0 || len(y) == 0 || len(labels) == 0 {
        return errors.New("Illegal argumet"), Empty_Graph
    }
    proj := bson.M{}
    for i := 0; i < secs_per_doc; i++ {
        sec_pref := cnv.Itoa(i) + "."
        proj[sec_pref + y] = 1
        proj[sec_pref + x] = 1
        for a := range labels {
            proj[sec_pref + labels[a]] = 1
        }
    }

    query := bson.M{"_id":bson.M{"$gte":objId(from)},"$lt":objId(to)}


    s := masterSession.ms.Copy()
    coll := s.DB(db).C(c)
    defer s.Close()
    cur := coll.Find(query).Select(proj).Iter()

    res := make(map[string]Points)
    entry := bson.M{}

    for cur.Next(&entry) {
        xx, x_ok := entry[x].(float32)
        yy, y_ok := entry[y].(float32)
        if x_ok && y_ok {
            point := XY{xx, yy}
            labelStr := ""
            for i := range labels {
                label, ok := entry[labels[i]].(string)
                if !ok {
                    continue
                }
                if len(label) > 0 {
                    labelStr = labelStr + ":" + label
                }
            }
            if len(labelStr) > 0 {
                if val, ok := res[labelStr];ok {
                    n := len(val)
                    if cap(val) == n {
                        res[labelStr] = make(Points, n, 2*n+1)
                        copy(res[labelStr], val)
                    }
                    res[labelStr] = res[labelStr][0:n+1]
                    res[labelStr][n] = point

                } else {
                    res[labelStr] = make(Points, 100, 200)
                    res[labelStr][0] = point
                }
            }

        }
    }

    if err := cur.Close(); err != nil {
        return err, Empty_Graph
    }

    return nil, res
}

func GetKV(db, c, k string) string {
    s := masterSession.ms.Copy()
    coll := s.DB(db).C(c)
    defer s.Close()
    res := bson.M{}
    err := coll.Find(bson.M{"_id":k}).Select(bson.M{"_id":1}).One(&res)
    if err != nil {
        log.Printf("Error retrieving value by key [%v].\n", k)
        log.Println(err.Error())
        return "N/A"
    }
    if str, ok := res["_id"].(string); ok {
        return str
    } else {
        return "N/A"
    }
}

func GetFilteredCollections(dbName, reStr string) (error, []string) {
    re, err := regexp.Compile(reStr)
    if err != nil {
        return err, []string{}
    }
    s := masterSession.ms.Copy()
    db := s.DB(dbName)
    defer s.Close()
    collections, err := db.CollectionNames()
    if err != nil {
        return err, collections
    }

    c_size := len(collections)

    if c_size > 0 {

        cnt := 0
        res := make([]string, c_size)
        for a := range collections {
            if re.MatchString(collections[a]) {
                res[cnt] = collections[a]
                cnt = cnt + 1
            }
        }

        return nil, res[:cnt]
    } else {
        return nil, []string{}
    }
}


//TODO will need to round up for upper bound
func objId(t time.Time) string {
    nt := t.Truncate(time.Minute)
    nt_sec := nt.Unix()
    dt_hex := cnv.FormatInt(nt_sec, 16)
    return dt_hex + zero_host
}

